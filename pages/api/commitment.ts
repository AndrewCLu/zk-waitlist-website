import type { NextApiRequest, NextApiResponse } from 'next';
import { getErrorMessage } from '../../utils/Errors';
/* eslint-disable @typescript-eslint/no-var-requires */
const snarkjs = require('snarkjs');
const path = require('path');
const fs = require('fs')
/* eslint-enable @typescript-eslint/no-var-requires */

// Runs the prover specified by circuit with given input
// Returns the resulting proof and publicSignals, or an error if encountered
// We copy this function across api endpoints to avoid loading unnecessary circuit dependencies for each given endpoint, which would place the serverless function beyond the size limit
const generateCommitmentProof = async (
  input: any
): Promise<{ proof: any; publicSignals: any } | Error> => {
  try {
    const verificationKeyPath = path.resolve(
      'public/circuits/poseidon_2/poseidon_2_verification_key.json'
    );
    const verificationKey = JSON.parse(fs.readFileSync(verificationKeyPath));
    throw Error(verificationKey.toString())
    const { proof, publicSignals } = await snarkjs.plonk.fullProve(
      input,
      path.resolve('public/circuits/poseidon_2/poseidon_2.wasm'),
      path.resolve('public/circuits/poseidon_2/poseidon_2_final.zkey')
    );
    return { proof, publicSignals };
  } catch (error) {
    return Error(getErrorMessage(error));
  }
};

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  const {
    query: { secret },
  } = req;

  // Only allow GET requests
  if (req.method !== 'GET') {
    return res.status(405).json({ error: 'Method not allowed' });
  }

  // Secret must be a string
  if (typeof secret !== 'string') {
    return res.status(400).send({ error: 'invalid secret parameter' });
  }
  const secretString = secret as string;

  // Secret must be convertable to a BigInt
  try {
    BigInt(secretString);
  } catch (e) {
    return res.status(400).send({ error: 'secret is not a valid BigInt' });
  }

  // Commitments are generated by poseidon hashing the secret with 0
  const proofInput = { inputs: [secretString, '0'] };
  const proofResult = await generateCommitmentProof(proofInput);
  if (proofResult instanceof Error) {
    return res.status(400).send({ error: proofResult.message });
  }
  const { publicSignals } = proofResult;
  res.status(200).json({ commitment: publicSignals[0] });
}
