import type { NextApiRequest, NextApiResponse } from 'next';
const snarkjs = require("snarkjs");
const path = require('path');

interface CommitmentApiRequest extends NextApiRequest {
  query: {
    secret: string
  }
}

type CommitmentApiResponse = NextApiResponse<Commitment | ErrorResponse>;

type Commitment = {
  commitment: string
}

type ErrorResponse = {
  error: string
}

export default async function handler(req: CommitmentApiRequest, res: CommitmentApiResponse) {
  const {
    query: { secret }
  } = req

  // Secret must be convertable to a BigInt
  try {
    BigInt(secret);
  } catch (e) {
    res.status(400).send({ error: 'failed to fetch data' })
    return;
  }

  const proofInput = { "inputs": [secret, "0"] }; // Commitments are generated by poseidon hashing the secret with 0
	const { publicSignals } = await snarkjs.plonk.fullProve(proofInput, path.join('circuits/poseidon_2/', 'poseidon_2.wasm'), path.join('circuits/poseidon_2/', 'poseidon_2_final.zkey'));
  res.status(200).json({ commitment: publicSignals[0] });
}